/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  LookalikeView: () => LookalikeView,
  NOTE_PROXIMITY_VIEW: () => NOTE_PROXIMITY_VIEW,
  default: () => LookalikePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// TfIdf.ts
var TfIdf = class {
  constructor() {
    this.corpus = /* @__PURE__ */ new Map();
  }
  getWordsFromText(document) {
    return document.replace(/[\r\n]/g, " ").trim().split(/\W+/);
  }
  /*
   * Breaks a string into an array of words (aka document)
   */
  addDocument(document) {
    let strArray = this.getWordsFromText(document.text);
    this.corpus.set(document.path, strArray);
    return this.corpus;
  }
  /*
   * Creates a corpus from an array of documents
   */
  createCorpusFromStringArray(documents) {
    for (let i = 0; i < documents.length; i++) {
      let strArray = this.getWordsFromText(documents[i].text);
      this.corpus.set(documents[i].path, strArray);
    }
    return this.corpus;
  }
  /*
   * Calculates the term frequency (tf) of a given term in a document
   * Term frequency is computed as:
   * number of occurrences of the term / length of document;
   */
  calculateTermFrequency(term, document) {
    let numOccurences = 0;
    for (let i = 0; i < document.length; i++) {
      if (document[i].toLowerCase() == term.toLowerCase()) {
        numOccurences++;
      }
    }
    return numOccurences * 1 / (document.length + 1);
  }
  /*
   * Calculates the inverse document frequency (idf) of a term in a given document
   * idf = log(number of documents where the term appears / term frequency)
   */
  calculateInverseDocumentFrequency(term) {
    if (this.corpus == null)
      return -1;
    let numDocs = 0;
    for (const document of this.corpus.values()) {
      for (let j = 0; j < document.length; j++) {
        if (document[j] == term.toLowerCase()) {
          numDocs++;
          break;
        }
      }
    }
    return Math.log(this.corpus.size / (numDocs + 1)) + 1;
  }
  /*
   * Creates a vector of the idf of the query term in a given document
   */
  createIdfModel(query) {
    query = Array.isArray(query) ? query : query.split(" ");
    if (this.corpus == null)
      return null;
    let model = [];
    for (let i = 0; i < query.length; i++) {
      model.push(this.calculateInverseDocumentFrequency(query[i]));
    }
    return model;
  }
  /*
   * creates a vector of the tf-idf values for each query term
   * tf-idf = tf * idf
   */
  createVectorSpaceModel(query, document) {
    query = Array.isArray(query) ? query : query.split(" ");
    if (this.corpus == null)
      return null;
    let termFrequencyModel = [];
    let vectorSpaceModel = [];
    for (let i = 0; i < query.length; i++) {
      termFrequencyModel.push(
        this.calculateTermFrequency(query[i], document)
      );
    }
    let idfModel = this.createIdfModel(query);
    if (idfModel == null)
      return null;
    for (let j = 0; j < idfModel.length; j++) {
      vectorSpaceModel[j] = idfModel[j] * termFrequencyModel[j];
    }
    return vectorSpaceModel;
  }
  /*
   * calculates the cosine similarity between two vectors computed as thier dot
   * product. The higher the cosine similarity of a given document the closer of
   * a match it is to the query.
   */
  calculateSimilarityIndex(query, document) {
    query = Array.isArray(query) ? query : query.split(" ");
    let query_vector = this.createVectorSpaceModel(query, query);
    let doc_vector = this.createVectorSpaceModel(query, document);
    let similarityIndex = 0;
    for (let i = 0; i < query.length; i++) {
      let toAdd = query_vector[i] * doc_vector[i];
      if (isNaN(toAdd)) {
        similarityIndex += 0;
      } else {
        similarityIndex += toAdd;
      }
    }
    let query_mag = this.calculateMagnitude(query_vector);
    let doc_mag = this.calculateMagnitude(doc_vector);
    let similarity = 1 * similarityIndex / (query_mag * doc_mag);
    return isNaN(similarity) ? 0 : similarity;
  }
  /*
   * Ranks the documents in your corpus according to a query
   */
  rankDocumentsByQuery(query, limit = 10, excludePath) {
    const queryParts = query.split(" ");
    let ranking = [];
    for (const [path, document] of this.corpus.entries()) {
      ranking.push({
        document,
        similarityIndex: this.calculateSimilarityIndex(
          queryParts,
          document
        ),
        path
      });
    }
    ranking.sort((a, b) => {
      return b.similarityIndex - a.similarityIndex;
    });
    return ranking.filter(
      (document) => excludePath ? document.path != excludePath : true
    ).splice(0, limit);
  }
  /*
   * Calculates the magnitude of an input vector
   */
  calculateMagnitude(vector) {
    let magnitude = 0;
    for (let i = 0; i < vector.length; i++) {
      if (isNaN(vector[i])) {
        magnitude += 0;
      } else {
        magnitude += vector[i] * vector[i];
      }
    }
    return Math.sqrt(magnitude);
  }
};

// main.ts
var NOTE_PROXIMITY_VIEW = "note-proximity-view";
var LookalikePlugin = class extends import_obsidian.Plugin {
  async onload() {
    this.registerView(
      NOTE_PROXIMITY_VIEW,
      (leaf) => new LookalikeView(leaf)
    );
    this.registerEvent(
      this.app.vault.on("create", this.onFileChange.bind(this))
    );
    this.registerEvent(
      this.app.vault.on("modify", this.onFileChange.bind(this))
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        if ((leaf == null ? void 0 : leaf.view.file) && "path" in (leaf == null ? void 0 : leaf.view.file)) {
          if ((leaf == null ? void 0 : leaf.view.file) instanceof import_obsidian.TFile) {
            this.onFileChange(leaf == null ? void 0 : leaf.view.file);
          }
        }
      })
    );
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile && activeFile instanceof import_obsidian.TFile) {
      this.onFileChange(activeFile);
    }
    this.addCommand({
      id: "open-sidebar",
      name: "Open Lookalike sidebar",
      callback: () => {
        const previousLeaf = this.app.workspace.getMostRecentLeaf();
        this.activateView();
        if (previousLeaf) {
          this.onFileChange(previousLeaf == null ? void 0 : previousLeaf.view.file);
        }
      }
    });
    await this.activateView();
  }
  // TODO: should probably optimise to add/remove only the new/changed file
  async onFileChange(file) {
    const rankings = await this.calculateTfIdf(file);
    await this.updateView(rankings);
  }
  onunload() {
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(NOTE_PROXIMITY_VIEW);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await (leaf == null ? void 0 : leaf.setViewState({
        type: NOTE_PROXIMITY_VIEW,
        active: true
      }));
    }
    if (leaf)
      workspace.revealLeaf(leaf);
  }
  async updateView(rankings) {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(NOTE_PROXIMITY_VIEW);
    if (leaves.length > 0) {
      const view = leaves[0].view;
      view.update(rankings);
    }
  }
  async calculateTfIdf(currentFile) {
    const { vault } = this.app;
    const tfIdf = new TfIdf();
    const files = vault.getMarkdownFiles();
    for (const file of files) {
      const text = await vault.cachedRead(file);
      tfIdf.addDocument({ text, path: file.path });
    }
    const rankings = tfIdf.rankDocumentsByQuery(
      await vault.cachedRead(currentFile),
      10,
      currentFile.path
    );
    return rankings;
  }
};
var LookalikeView = class extends import_obsidian.ItemView {
  constructor(leaf) {
    super(leaf);
  }
  getViewType() {
    return NOTE_PROXIMITY_VIEW;
  }
  getDisplayText() {
    return "Note proximity";
  }
  async onOpen() {
  }
  async update(rankings) {
    const container = this.containerEl.children[1];
    container.empty();
    container.createEl("div", {
      // text: "Similar notes:",
      cls: "tree-item"
    }).createEl("div", {
      cls: ["tree-item-inner", "backlink-pane"],
      text: "Similar notes:"
    }).setCssStyles({
      color: "var(--text-muted)",
      fontSize: "var(--font-adaptive-smallest)",
      fontWeight: "var(--nav-heading-weight)",
      letterSpacing: ".05em",
      textTransform: "uppercase"
    });
    const searchResultContainer = container.createEl("div", {
      cls: ["search-results-container"]
    });
    const searchResultsChildren = searchResultContainer.createEl("div", {
      cls: ["search-results-children"]
    });
    for (const { path, similarityIndex } of rankings) {
      const searchResult = searchResultsChildren.createEl("div", {
        cls: ["tree-item", "search-result-file-title"]
      });
      searchResult.onclick = () => {
        this.app.workspace.openLinkText(path, "", false);
      };
      searchResult.createEl("div", {
        cls: ["tree-item-self", "is-clickable"]
      }).createEl("div", {
        text: `(${similarityIndex.toFixed(3)}) ${path}`,
        cls: ["tree-item-inner"]
      });
    }
  }
  async onClose() {
  }
};

/* nosourcemap */